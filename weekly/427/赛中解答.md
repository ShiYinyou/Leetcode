# 第 427 次周赛

本次周赛成功解出前两题，总得分为 **7** 分，成绩总排名为 **815**，更新的累积竞赛分为 **XXXX**。

* [x] Q1一次通过
* [x] Q2求解出错，一次罚时
* [ ] Q3在求解时超时
* [ ] Q4未求解

---

---

## Q1: 3379. 转换数组

> $\textbf{\textcolor{green}{简单}}~~~~~~~~$ 分数：

给你一个整数数组 `nums`，它表示一个循环数组。请你遵循以下规则创建一个大小 **相同** 的新数组 `result` ：

对于每个下标 `i`（其中 `0 <= i < nums.length`），独立执行以下操作：

* 如果 `nums[i] > 0`：从下标 `i` 开始，向 **右** 移动 `nums[i]` 步，在循环数组中落脚的下标对应的值赋给 `result[i]`。

* 如果 `nums[i] < 0`：从下标 `i` 开始，向 **左** 移动 `abs(nums[i])` 步，在循环数组中落脚的下标对应的值赋给 `result[i]`。

* 如果 `nums[i] == 0`：将 `nums[i]` 的值赋给 `result[i]`。

返回新数组 `result`。

注意：由于 `nums` 是循环数组，向右移动超过最后一个元素时将回到开头，向左移动超过第一个元素时将回到末尾。

### 解题思路

相当于对于每个下标 `i` 及其对应的元素 `x`，从 `i` 向右移动 `x` 个位置，对应的元素就是下标 `i` 更新的结果。

在python中，测试了 `-1 % 4 = 3`，说明负数也可以正常通过取模被映射到 `[0,m-1]` 的范围。

那么只需要将每个 `i` 位置替换成 `nums[(i+x)%m]` 即可。

### 代码及测试结果

``` python
class Solution:
    def constructTransformedArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        result = [0]*n
        for i,x in enumerate(nums):
            result[i] = nums[(i+x)%n]
        return result
```

``` python
执行通过
```

### 复杂度分析

* 时间复杂度：$O(n)$
* 空间复杂度：$O(1)$

---

## Q2: 3380. 用点构造面积最大的矩形 I

> $\textbf{\textcolor{orange}{中等}}~~~~~~~~$ 分数：

给你一个数组 `points`，其中 `points[i] = [xi, yi]` 表示无限平面上一点的坐标。

你的任务是找出满足以下条件的矩形可能的 **最大** 面积：

- 矩形的四个顶点必须是数组中的 **四个** 点。
- 矩形的内部或边界上 **不能** 包含任何其他点。
- 矩形的边与坐标轴 **平行** 。

返回可以获得的 **最大面积** ，如果无法形成这样的矩形，则返回 -1。

### 解题思路

1. 从端点中选出两个对角点，如果确定的矩形的另两个端点也在数组中，说明可以构造出一个矩形。
2. 如果构造出了矩形，判断是否有点在矩形上或矩形内。
    1. 通过测试，二维数组的排序首先按照第一个元素排序，然后再根据第二个元素排序。
    2. 排序后，当检查到某个点的横坐标值超过了矩形范围，则后续均不需要再检查。

### 代码及测试结果

``` python
class Solution:
    def maxRectangleArea(self, points: List[List[int]]) -> int:
        def check():
            for z in points:
                if z in [x,y,[x[0],y[1]],[x[1],y[0]]]:
                    continue
                if mnx<=z[0]<=mxx and mny<=z[1]<=mxy:
                    return False
                elif z[0]>mxx:
                    break
            return True
        ans = 0
        points.sort()
        n = len(points)
        for i in range(n-1):
            x = points[i]
            for j in range(i,n):
                y = points[j]
                if x[0]==y[0] or x[1]==y[1]:
                    continue
                elif [x[0],y[1]] in points and [x[1],y[0]] in points:
                    mnx,mxx = x[0],y[0]
                    mny = min(x[1],y[1])
                    mxy = max(x[1],y[1])
                    if check():
                        ans = max(ans,(mxx-mnx)*(mxy-mny))
        return ans if ans!=0 else -1
```

``` python
解答错误
输入：[[100,80],[67,79],[100,79],[67,80],[80,47]]
输出：-1
预期：33
```

通过debug，发现在检查过程中，并没有将几个端点从检查点中取出，导致结果出错

``` python
class Solution:
    def maxRectangleArea(self, points: List[List[int]]) -> int:
        def check():
            for z in points:
                if z in [x,y,[x[0],y[1]],[y[0],x[1]]]:
                    continue
                if mnx<=z[0]<=mxx and mny<=z[1]<=mxy:
                    return False
                elif z[0]>mxx:
                    break
            return True
        ans = 0
        points.sort()
        n = len(points)
        for i in range(n-1):
            x = points[i]
            for j in range(i+1,n):
                y = points[j]
                if x[0]==y[0] or x[1]==y[1]:
                    continue
                elif [x[0],y[1]] in points and [y[0],x[1]] in points:
                    mnx,mxx = x[0],y[0]
                    mny = min(x[1],y[1])
                    mxy = max(x[1],y[1])
                    if check():
                        ans = max(ans,(mxx-mnx)*(mxy-mny))
        return ans if ans!=0 else -1
```

``` python
执行通过
```

### 复杂度分析

* 时间复杂度：$O(n^3)$，遍历两个端点需要$O(n^2)$，确定端点后检查所有节点还需要一次循环。
* 空间复杂度：$O(1)$

---

## Q3: 3381. 长度可被 K 整除的子数组的最大元素和

> $\textbf{\textcolor{orange}{中等}}~~~~~~~~$ 分数：

给你一个整数数组 `nums` 和一个整数 `k` 。

返回 `nums` 中一个 **非空子数组** 的 **最大** 和，要求该子数组的长度可以 **被** `k` **整除** 。

**子数组** 是数组中一个连续的、非空的元素序列。

### 解题思路

考虑采用固定大小滑动窗口。

1. 外循环遍历k的倍数
2. 内循环用滑窗遍历数组

### 代码及测试结果

``` python
class Solution:
    def maxSubarraySum(self, nums: List[int], k: int) -> int:
        n = len(nums)
        ans = -inf
        for k in range(k,n+1,k):
            s = sum(nums[0:k])
            ans = max(ans,s)
            for i in range(n-k):
                s = s-nums[i]+nums[i+k]
                ans = max(ans,s)
        return ans
```

``` python
超出时间限制
```

使用滑窗 和 直接双指针遍历 的时间复杂度相同，并没有减小算法的复杂度。

### 复杂度分析

* 时间复杂度：$O(n^2)$
* 空间复杂度：$O(1)$

---

## Q4: 3382. 用点构造面积最大的矩形 II

> $\textbf{\textcolor{red}{困难}}~~~~~~~~$ 分数：

在Q2的基础上增加了点的数量及取值域。

### 解题思路

如果采用Q2方法，一定会超时。

未想到解决方法，未进行求解。