class Template:
    def backtracking():
        """
        回溯：
        从原问题到子问题的过程，适合用递归解决。
        通过递归，可以达到多重循环的效果。
        回溯有一个 增量 构造答案的过程，这个过程通常用递归实现
        这个增量构造答案的过程可以画成一棵树

        只需要把边界条件和非边界条件写对就行

        回溯问题可以分为子集型回溯、组合型回溯、排列型回溯

        思考回溯问题和动态规划问题的模版：
        用一个path数组记录路径上的字母
        **回溯三问**：
        1. 当前操作？
        2. 子问题？
        3. 下一个子问题
        dfs(i) -> dfs(i+1) 第i个子问题，然后递归到第i+1个子问题
        
        时间复杂度为O(n*d^n)，每一个i最多有d个选项，生成答案需要花费O(n)时间
        空间复杂度为O(n)
        """
        ans = []
        path = [''] * n
        def dfs(i):
            if 边界条件:
                ans.append(path)
                return 
            # 非边界条件
            for c in 候选集:
                path[i] = c
                dfs(i+1)
        dfs(0)
        return ans
    

    def backtracking_subset():
        """
        子集型回溯：每个元素都可以选择 **选/不选**

        两种思考方式：
        #1. 站在 *输入* 的角度思考：
            每个数可以在子集中（选），也可以不在子集中（不选）
            叶子节点是答案
            **回溯三问**：
            1. 当前操作？  枚举第i个数选/不选
            2. 子问题？  从下标>=i的数字中构造子集
            3. 下一个子问题  从下标>=i+1的数字中构造子集
            dfs(i) -> dfs(i+1)
        #2. 站在 *答案* 的角度思考：
            枚举第一个数选谁、第二个数选谁……
            每个节点都是答案
            [1,2]和[2,1]是重复子集，
            为避免重复，下一个数应大于当前选择的数
            **回溯三问**：
            1. 当前操作？  枚举一个下标j>=i的数字，加入path
            2. 子问题？  从下标>=i的数字中构造子集
            3. 下一个子问题  从下标>=j+1的数字中构造子集
            dfs(i) -> dfs(i+1)/dfs(i+2)/……/dfs(n)
        
        时间复杂度为O(n*d^n)，每一个i最多有d个选项，生成答案需要花费O(n)时间
        空间复杂度为O(n)
        """
        pass